{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/cjs/index.js","dist/cjs/lib/_computed_queue.js","dist/cjs/lib/_domComponent.js","dist/cjs/lib/_domDispose.js","dist/cjs/lib/_domImpl.js","dist/cjs/lib/_domMethods.js","dist/cjs/lib/binding.js","dist/cjs/lib/browserGlobals.js","dist/cjs/lib/computed.js","dist/cjs/lib/dispose.js","dist/cjs/lib/dom.js","dist/cjs/lib/domevent.js","dist/cjs/lib/emit.js","dist/cjs/lib/kowrap.js","dist/cjs/lib/observable.js","dist/cjs/lib/subscribe.js","dist/cjs/lib/util.js","node_modules/fastpriorityqueue/FastPriorityQueue.js"],"names":["f","exports","module","define","amd","window","global","self","this","grainjs","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","__export","m","p","hasOwnProperty","Object","defineProperty","value","FastPriorityQueue","DepItem","[object Object]","callback","optContext","_priority","_enqueued","_callback","_context","b","depItem","queue","add","isPrioritySmaller","_seen","bundleDepth","compute","size","item","poll","push","recompute","_getPriority","obs","_getDepItem","bundleChanges","func","_domDispose_1","_domImpl_1","dispose_1","browserGlobals_1","Component","Disposable","args","elem","content","render","_markerPre","G","document","createComment","_markerPost","onDisposeElem","undefined","dispose","autoDisposeWith","_unmount","update","parentNode","next","nextSibling","domDispose","removeChild","createElem","ComponentClass","create","createInit","pop","initFunc","_disposeMap","WeakMap","_disposeElem","disposer","get","key","delete","disposerFunc","prevDisposer","set","autoDisposeElem","disposable","_walkDom","visitFunc","c","firstChild","onDispose","autoDispose","_domMethods_1","_createElementHtml","tag","createElement","_createElementSvg","createElementNS","_createFromTagString","createFunc","tagString","id","classes","dotPos","indexOf","hashPos","substring","replace","setAttribute","_updateWithArgs","arg","_updateWithArg","_updateWithArgsOrDispose","Array","isArray","Node","appendChild","attrsElem","createTextNode","dom","svg","frag","createDocumentFragment","find","selector","querySelector","findAll","querySelectorAll","binding_1","_dataMap","_subscribe","valueObs","subscribe","attrsObj","keys","attrElem","attrName","attrValue","removeAttribute","boolAttrElem","boolValue","styleElem","property","style","propElem","showElem","display","hideElem","toggleClassElem","className","classList","toggle","Boolean","dataElem","obj","domComputed","contentFunc","_contentFunc","identity","markerPre","markerPost","insertBefore","_replaceContent","attrs","attr","attrValueObs","val","boolAttr","boolValueObs","textElem","text","textNode","nodeValue","prop","show","hide","toggleClass","cssClassElem","cssClass","classNameObs","prevClass","name","remove","data","getData","maybe","computed_1","observable_1","koValue","peek","savedValue","sub","old","comp","computed","addListener","Observable","_updateGlobals","dest","source","DocumentFragment","Element","initial","assign","_globalsStack","pushGlobals","globals","popGlobals","subscribe_1","_noWrite","Computed","dependencies","super","_write","_sub","Subscription","_read","bind","writeFunc","use","readCb","_callFuncHelper","_wipeOutObject","forEach","k","_disposeHelper","owner","console","error","_describe","constructor","_defaultDisposer","_disposalList","methodName","_obj","list","index","findIndex","entry","splice","_domComponent","_domDispose","_domImpl","_domMethods","domevent","onElem","on","onMatchElem","onMatch","DomEventListener","eventType","useCapture","addEventListener","event","cb","removeEventListener","DomEventMatchListener","inner","outer","el","parentElement","matches","_findMatch","target","_noop","LLink","_next","_prev","node","last","Emitter","_changeCB","_changeCBContext","Listener","callAll","changeCB","hasListeners","_disposeList","emitter","context","_insertBefore","_triggerChangeCB","begin","end","lis","isDisposed","_removeNode","fromKoWrappers","toKoWrappers","fromKo","koObservable","prevObs","newObs","observable","toKo","knockout","grainObs","prevKoObs","newKoObs","_computed_queue_1","emit_1","_computed_queue_2","_onChange","_value","prev","emit","setChangeCB","emptyArray","_depItem","_evaluate","_dependencies","_depListeners","map","_subscribeTo","_dynDeps","Map","_useFunc","_useDependency","values","listener","_inUse","useDep","readArgs","len","apply","_enqueue","enqueue","bindB","bindUB","bindBU","defaultcomparator","comparator","array","compare","prototype","myval","ap","heapify","arr","_percolateDown","_percolateUp","bestc","hsize","ai","ans","replaceTop","trim","slice","isEmpty","main","x","log"],"mappings":"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","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./lib/computed\"));\n__export(require(\"./lib/dispose\"));\n__export(require(\"./lib/dom\"));\n__export(require(\"./lib/domevent\"));\n__export(require(\"./lib/emit\"));\n__export(require(\"./lib/kowrap\"));\n__export(require(\"./lib/observable\"));\n__export(require(\"./lib/subscribe\"));\n__export(require(\"./lib/util\"));\n","\"use strict\";\n/**\n * This module supports computed observables, organizing them into a priority queue, so that\n * computeds can be updated just once after multiple bundled changes.\n *\n * This module is for internal use only (hence the leading underscore in the name). The only\n * function useful outside is exposed via the `observable` module as `observable.bundleChanges()`.\n *\n * Changes may come together because multiple observables are changed synchronously, or because\n * multiple computeds depend on a single changed observable. In either case, if a computed depends\n * on multiple observables that are being changed, we want it to just get updated once when the\n * changes are complete.\n *\n * This is done by maintaining a _priority in each computed, where greater values get evaluated\n * later (computed with greater values depend on those with smaller values). When a computed needs\n * updating, it adds itself to the queue using enqueue() method. At the end of an observable.set()\n * call, or of bundleChanges() call, the queue gets processed in order of _priority.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst FastPriorityQueue = require(\"fastpriorityqueue\");\n/**\n * DepItem is an item in a dependency relationship. It may depend on other DepItems. It is used\n * for subscriptions and computed observables.\n */\nclass DepItem {\n    /**\n     * Callback should call depItem.useDep(dep) for each DepInput it depends on.\n     */\n    constructor(callback, optContext) {\n        this._priority = 0;\n        this._enqueued = false;\n        this._callback = callback;\n        this._context = optContext;\n    }\n    static isPrioritySmaller(a, b) {\n        return a._priority < b._priority;\n    }\n    /**\n     * Mark depItem as a dependency of this DepItem. The argument may be null to indicate a leaf (an\n     * item such as a plain observable, which does not itself depend on anything else).\n     */\n    useDep(depItem) {\n        const p = depItem ? depItem._priority : 0;\n        if (p >= this._priority) {\n            this._priority = p + 1;\n        }\n    }\n    /**\n     * Recompute this DepItem, calling the callback given in the constructor.\n     */\n    recompute() {\n        this._priority = 0;\n        this._callback.call(this._context);\n    }\n    /**\n     * Add this DepItem to the queue, to be recomputed when the time is right.\n     */\n    enqueue() {\n        if (!this._enqueued) {\n            this._enqueued = true;\n            queue.add(this);\n        }\n    }\n}\nexports.DepItem = DepItem;\n// The main compute queue.\nconst queue = new FastPriorityQueue(DepItem.isPrioritySmaller);\n// Array to keep track of items recomputed during this call to compute(). It could be a local\n// variable in compute(), but is made global to minimize allocations.\nconst _seen = [];\n// Counter used for bundling multiple calls to compute() into one.\nlet bundleDepth = 0;\n/**\n * Exposed for unittests. Returns the internal priority value of an observable.\n */\nfunction _getPriority(obs) {\n    const depItem = obs._getDepItem();\n    return depItem ? depItem._priority : 0;\n}\nexports._getPriority = _getPriority;\n/**\n * Update any computed observables that need updating. The update is deferred if we are currently\n * in the middle of a bundle. This is called automatically whenever you set an observable, and\n * there should be no need to ever call this by users of the library.\n */\nfunction compute() {\n    if (bundleDepth === 0 && queue.size > 0) {\n        // Prevent nested compute() calls, which are unnecessary and can cause deep recursion stack.\n        bundleDepth++;\n        try {\n            // We reuse _seen array to minimize allocations, but always leave it empty.\n            do {\n                const item = queue.poll();\n                _seen.push(item);\n                item.recompute();\n            } while (queue.size > 0);\n        }\n        finally {\n            // We delay the unsetting of _enqueued flag to here, to protect against infinite loops when\n            // a change to a computed causes it to get enqueued again.\n            for (const item of _seen) {\n                item._enqueued = false;\n            }\n            _seen.length = 0;\n            bundleDepth--;\n        }\n    }\n}\nexports.compute = compute;\n/**\n * Defer recomputations of all computed observables and subscriptions until func() returns. This\n * is useful to avoid unnecessary recomputation if you are making several changes to observables\n * together. This function is exposed as `observable.bundleChanges()`.\n *\n * Note that this intentionally does not wait for promises to be resolved, since that would block\n * all updates to all computeds while waiting.\n */\nfunction bundleChanges(func) {\n    try {\n        bundleDepth++;\n        return func();\n    }\n    finally {\n        bundleDepth--;\n        compute();\n    }\n}\nexports.bundleChanges = bundleChanges;\n","\"use strict\";\n/**\n * Implementation of UI components that can be inserted into dom(). See documentation for\n * createElem() and create().\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _domDispose_1 = require(\"./_domDispose\");\nconst _domImpl_1 = require(\"./_domImpl\");\nconst dispose_1 = require(\"./dispose\");\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nconst browserGlobals_1 = require(\"./browserGlobals\");\n/**\n * A UI component should extend this base class and implement `render()`. Compared to a simple\n * function returning DOM (a \"functional\" component), a \"class\" component makes it easier to\n * organize code into methods.\n *\n * In addition, a \"class\" component may be disposed to remove it from the DOM, although this is\n * uncommon since a UI component is normally owned by its containing DOM.\n */\nclass Component extends dispose_1.Disposable {\n    /**\n     * Components must extend this class and implement a `render()` method, which is called at\n     * construction with constructor arguments, and should return DOM for the component.\n     *\n     * It is recommended that any constructor work is done in this method.\n     *\n     * render() may return any type of value that's accepted by dom() as an argument, including a\n     * DOM element, a string, null, or an array. The returned DOM is automatically owned by the\n     * component, so do not wrap it in `this.autoDispose()`.\n     */\n    render(...args) {\n        throw new Error(\"Not implemented\");\n    }\n    /**\n     * This is not intended to be called directly or overridden. Instead, implement render().\n     */\n    create(elem, ...args) {\n        const content = this.render(...args);\n        this._markerPre = browserGlobals_1.G.document.createComment('A');\n        this._markerPost = browserGlobals_1.G.document.createComment('B');\n        // If the containing DOM is disposed, it will dispose all of our DOM (included among children\n        // of the containing DOM). Let it also dispose this Component when it gets to _markerPost.\n        // Since _unmount() is unnecessary here, we skip its work by unseting _markerPre/_markerPost.\n        _domDispose_1.onDisposeElem(this._markerPost, () => {\n            this._markerPre = this._markerPost = undefined;\n            this.dispose();\n        });\n        // When the component is disposed, unmount the DOM we created (i.e. dispose and remove).\n        // Except that we skip this as unnecessary when the disposal is triggered by containing DOM.\n        this.autoDisposeWith(this._unmount, this);\n        // Insert the result of render() into the given parent element.\n        _domImpl_1.update(elem, this._markerPre, content, this._markerPost);\n    }\n    /**\n     * Detaches and disposes the DOM created and attached in _mount().\n     */\n    _unmount() {\n        // Dispose the owned content, and remove it from the DOM.\n        if (this._markerPre && this._markerPre.parentNode) {\n            let next;\n            const elem = this._markerPre.parentNode;\n            for (let n = this._markerPre.nextSibling; n && n !== this._markerPost; n = next) {\n                next = n.nextSibling;\n                _domDispose_1.domDispose(n);\n                elem.removeChild(n);\n            }\n            elem.removeChild(this._markerPre);\n            elem.removeChild(this._markerPost);\n        }\n    }\n}\nexports.Component = Component;\n/**\n * Construct and insert a UI component into the given DOM element. The component must extend\n * dom.Component(...), and must implement a `render(...)` method which should do any constructor\n * work and return DOM. DOM may be any type value accepted by dom() as an argument, including a\n * DOM element, string, null, or array. The returned DOM is automatically owned by the component.\n *\n * Logically, the parent `elem` owns the created component, and the component owns the DOM\n * returned by its render() method. If the parent is disposed, so is the component and its DOM. If\n * the component is somehow disposed directly, then its DOM is disposed and removed from `elem`.\n *\n * Note the correct usage:\n *\n *       dom('div', dom.create(Comp1), dom.create(Comp2, ...args))\n *\n * To understand why the syntax is such, consider a potential alterntive such as:\n *\n *       dom('div', _insert_(new Comp1()), _insert_(new Comp2(...args))\n *\n *    In both cases, the constructor for Comp1 runs before the constructor for Comp2. What happens\n *    when Comp2's constructor throws an exception? In the second case, nothing yet owns the\n *    created Comp1 component, and it will never get cleaned up. In the first, correct case,\n *    dom('div') element gets ownership of it early enough and will dispose it.\n *\n * @param {Element} elem: The element to which to append the newly constructed component.\n * @param {Class} ComponentClass: The component class to instantiate. It must extend\n *    dom.Component(...) and implement the render() method.\n * @param {Objects} ...args: Arguments to the constructor which passes them to the render method.\n */\nfunction createElem(elem, ComponentClass, ...args) {\n    // tslint:disable-next-line:no-unused-expression\n    new ComponentClass(elem, ...args);\n}\nexports.createElem = createElem;\nfunction create(ComponentClass, ...args) {\n    // tslint:disable-next-line:no-unused-expression\n    return (elem) => { new ComponentClass(elem, ...args); };\n}\nexports.create = create;\n/**\n * If you need to initialize a component after creation, you may do it in the middle of a dom()\n * call using createInit(), in which the last of args is initFunc: a function called with the\n * constructed instance of the component:\n *    dom.createInit(MyComponent, ...args, c => {\n *      c.addChild(...);\n *      c.setOption(...);\n *    });\n * The benefit of such inline construction is that the component is owned by the dom element as\n * soon as it's created, so an exception in the init function or later among dom()'s arguments\n * will trigger a cleanup.\n */\nfunction createInit(ComponentClass, ...args) {\n    return (elem) => {\n        const initFunc = args.pop();\n        const c = new ComponentClass(elem, ...args);\n        initFunc(c);\n    };\n}\nexports.createInit = createInit;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Private global disposal map. It maintains the association between DOM nodes and cleanup\n * functions added with dom.onDispose(). To support multiple disposers on one element, we use a\n * WeakMap-based linked list:\n *\n *    _disposeMap[elem] = disposer2;\n *    _disposeMap[disposer2] = disposer1;\n *    etc.\n *\n * This avoids allocating arrays or using undeclared properties for a different linked list.\n */\nconst _disposeMap = new WeakMap();\n// Internal helper to walk the DOM tree, calling visitFunc(elem) on all descendants of elem.\n// Descendants are processed first.\nfunction _walkDom(elem, visitFunc) {\n    let c = elem.firstChild;\n    while (c) {\n        // Note: this might be better done using an explicit stack, but in practice DOM trees aren't\n        // so deep as to cause problems.\n        _walkDom(c, visitFunc);\n        c = c.nextSibling;\n    }\n    visitFunc(elem);\n}\n// Internal helper to run all disposers for a single element.\nfunction _disposeElem(elem) {\n    let disposer = _disposeMap.get(elem);\n    if (disposer) {\n        let key = elem;\n        do {\n            _disposeMap.delete(key);\n            disposer(elem);\n            // Find the next disposer; these are chained when there are multiple.\n            key = disposer;\n            disposer = _disposeMap.get(key);\n        } while (disposer);\n    }\n}\n/**\n * Run disposers associated with any descendant of elem or with elem itself. Disposers get\n * associated with elements using dom.onDispose(). Descendants are processed first.\n *\n * It is automatically called if one of the function arguments to dom() throws an exception during\n * element creation. This way any onDispose() handlers set on the unfinished element get called.\n *\n * @param {Element} elem: The element to run disposers on.\n */\nfunction domDispose(elem) {\n    _walkDom(elem, _disposeElem);\n}\nexports.domDispose = domDispose;\n/**\n * Associate a disposerFunc with a DOM element. It will be called when the element is disposed\n * using domDispose() on it or any of its parents. If onDispose is called multiple times, all\n * disposerFuncs will be called in reverse order.\n * @param {Element} elem: The element to associate the disposer with.\n * @param {Function} disposerFunc(elem): Will be called when domDispose() is called on the\n *    element or its ancestor.\n * Note that it is not necessary usually to dispose event listeners attached to an element (e.g.\n * with dom.on()) since their lifetime is naturally limited to the lifetime of the element.\n */\nfunction onDisposeElem(elem, disposerFunc) {\n    const prevDisposer = _disposeMap.get(elem);\n    _disposeMap.set(elem, disposerFunc);\n    if (prevDisposer) {\n        _disposeMap.set(disposerFunc, prevDisposer);\n    }\n}\nexports.onDisposeElem = onDisposeElem;\nfunction onDispose(disposerFunc) {\n    return (elem) => onDisposeElem(elem, disposerFunc);\n}\nexports.onDispose = onDispose;\n/**\n * Make the given element own the disposable, and call its dispose method when domDispose() is\n * called on the element or any of its parents.\n * @param {Element} elem: The element to own the disposable.\n * @param {Disposable} disposable: Anything with a .dispose() method.\n */\nfunction autoDisposeElem(elem, disposable) {\n    if (disposable) {\n        onDisposeElem(elem, () => disposable.dispose());\n    }\n}\nexports.autoDisposeElem = autoDisposeElem;\nfunction autoDispose(disposable) {\n    if (disposable) {\n        return (elem) => autoDisposeElem(elem, disposable);\n    }\n}\nexports.autoDispose = autoDispose;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _domDispose_1 = require(\"./_domDispose\");\nconst _domMethods_1 = require(\"./_domMethods\");\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nconst browserGlobals_1 = require(\"./browserGlobals\");\n// The goal of the above declarations is to get help from TypeScript in detecting incorrect usage:\n//  import {text, hide} from './_domMethods';\n//  dom('div', text('hello'));        // OK\n//  dom('div', hide(true));           // OK\n//  dom('div', {title: 'hello'});     // OK\n//  frag(text('hello'));              // OK\n//  frag(hide(true));                 // Bad: DocumentFragment is not an Element\n//  frag({title: 'hello'});           // Bad: DocumentFragment is not an Element\n/**\n * dom('tag#id.class1.class2', ...args)\n *   The first argument is a string consisting of a tag name, with optional #foo suffix\n *   to add the ID 'foo', and zero or more .bar suffixes to add a CSS class 'bar'.\n *\n * The rest of the arguments are optional and may be:\n *\n *   Nodes - which become children of the created element;\n *   strings - which become text node children;\n *   objects - of the form {attr: val} to set additional attributes on the element;\n *   Arrays - which are flattened with each item processed recursively;\n *   functions - which are called with elem as the argument, for a chance to modify the\n *       element as it's being created. Return values are processed recursively.\n *   \"dom methods\" - expressions such as `dom.attr('href', url)` or `dom.hide(obs)`, which\n *       are actually special cases of the \"functions\" category.\n */\nfunction dom(tagString, ...args) {\n    return _updateWithArgsOrDispose(_createFromTagString(_createElementHtml, tagString), args);\n}\nexports.dom = dom;\n/**\n * svg('tag#id.class1.class2', ...args)\n *  Same as dom(...), but creates an SVG element.\n */\nfunction svg(tagString, ...args) {\n    return _updateWithArgsOrDispose(_createFromTagString(_createElementSvg, tagString), args);\n}\nexports.svg = svg;\n// Internal helper used to create HTML elements.\nfunction _createElementHtml(tag) {\n    return browserGlobals_1.G.document.createElement(tag);\n}\n// Internal helper used to create SVG elements.\nfunction _createElementSvg(tag) {\n    return browserGlobals_1.G.document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n}\n/**\n * Internal helper to parse tagString, create an element using createFunc with the given tag, and\n * set its id and classes from the tagString.\n * @param {Funtion} createFunc(tag): Function that should create an element given a tag name.\n *    It is passed in to allow creating elements in different namespaces (e.g. plain HTML vs SVG).\n * @param {String} tagString: String of the form \"tag#id.class1.class2\" where id and classes are\n *    optional.\n * @return {Element} The result of createFunc(), possibly with id and class attributes also set.\n */\nfunction _createFromTagString(createFunc, tagString) {\n    // We do careful hand-written parsing rather than use a regexp for speed. Using a regexp is\n    // significantly more expensive.\n    let tag;\n    let id;\n    let classes;\n    let dotPos = tagString.indexOf(\".\");\n    const hashPos = tagString.indexOf('#');\n    if (dotPos === -1) {\n        dotPos = tagString.length;\n    }\n    else {\n        classes = tagString.substring(dotPos + 1).replace(/\\./g, ' ');\n    }\n    if (hashPos === -1) {\n        tag = tagString.substring(0, dotPos);\n    }\n    else if (hashPos > dotPos) {\n        throw new Error(`ID must come before classes in dom(\"${tagString}\")`);\n    }\n    else {\n        tag = tagString.substring(0, hashPos);\n        id = tagString.substring(hashPos + 1, dotPos);\n    }\n    const elem = createFunc(tag);\n    if (id) {\n        elem.setAttribute('id', id);\n    }\n    if (classes) {\n        elem.setAttribute('class', classes);\n    }\n    return elem;\n}\nfunction update(elem, ...args) {\n    return _updateWithArgs(elem, args);\n}\nexports.update = update;\nfunction _updateWithArgs(elem, args) {\n    for (const arg of args) {\n        _updateWithArg(elem, arg);\n    }\n    return elem;\n}\nfunction _updateWithArgsOrDispose(elem, args) {\n    try {\n        return _updateWithArgs(elem, args);\n    }\n    catch (e) {\n        _domDispose_1.domDispose(elem);\n        throw e;\n    }\n}\nfunction _updateWithArg(elem, arg) {\n    if (typeof arg === 'function') {\n        const value = arg(elem);\n        // Skip the recursive call in the common case when the function returns nothing.\n        if (value !== undefined && value !== null) {\n            _updateWithArg(elem, value);\n        }\n    }\n    else if (Array.isArray(arg)) {\n        _updateWithArgs(elem, arg);\n    }\n    else if (arg === undefined || arg === null) {\n        // Nothing to do.\n    }\n    else if (arg instanceof browserGlobals_1.G.Node) {\n        elem.appendChild(arg);\n    }\n    else if (typeof arg === 'object') {\n        _domMethods_1.attrsElem(elem, arg);\n    }\n    else {\n        elem.appendChild(browserGlobals_1.G.document.createTextNode(arg));\n    }\n}\n/**\n * Creates a DocumentFragment processing arguments the same way as the dom() function.\n */\nfunction frag(...args) {\n    const elem = browserGlobals_1.G.document.createDocumentFragment();\n    return _updateWithArgsOrDispose(elem, args);\n}\nexports.frag = frag;\n/**\n * Find the first element matching a selector; just an abbreviation for document.querySelector().\n */\nfunction find(selector) { return browserGlobals_1.G.document.querySelector(selector); }\nexports.find = find;\n/**\n * Find all elements matching a selector; just an abbreviation for document.querySelectorAll().\n */\nfunction findAll(selector) { return browserGlobals_1.G.document.querySelectorAll(selector); }\nexports.findAll = findAll;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _domDispose_1 = require(\"./_domDispose\");\nconst _domImpl_1 = require(\"./_domImpl\");\nconst binding_1 = require(\"./binding\");\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nconst browserGlobals_1 = require(\"./browserGlobals\");\n/**\n * Private global map for associating arbitrary data with DOM. It's a WeakMap, so does not prevent\n * values from being garbage collected when the owning DOM elements are no longer used.\n */\nconst _dataMap = new WeakMap();\n/**\n * Internal helper that binds the callback to valueObs, which may be a value, observble, or\n * function, and attaches a disposal callback to the passed-in element.\n */\nfunction _subscribe(elem, valueObs, callback) {\n    _domDispose_1.autoDisposeElem(elem, binding_1.subscribe(valueObs, callback));\n}\n/**\n * Sets multiple attributes of a DOM element. The `attrs()` variant takes no `elem` argument.\n * @param {Object} attrsObj: Object mapping attribute names to attribute values.\n */\nfunction attrsElem(elem, attrsObj) {\n    for (const key of Object.keys(attrsObj)) {\n        elem.setAttribute(key, attrsObj[key]);\n    }\n}\nexports.attrsElem = attrsElem;\nfunction attrs(attrsObj) {\n    return (elem) => attrsElem(elem, attrsObj);\n}\nexports.attrs = attrs;\n/**\n * Sets an attribute of a DOM element to the given value. Removes the attribute when the value is\n * null or undefined. The `attr()` variant takes no `elem` argument, and `attrValue` may be an\n * observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} attrName: The name of the attribute to bind, e.g. 'href'.\n * @param {String|null} attrValue: The string value or null to remove the attribute.\n */\nfunction attrElem(elem, attrName, attrValue) {\n    if (attrValue === null || attrValue === undefined) {\n        elem.removeAttribute(attrName);\n    }\n    else {\n        elem.setAttribute(attrName, attrValue);\n    }\n}\nexports.attrElem = attrElem;\nfunction attr(attrName, attrValueObs) {\n    return (elem) => _subscribe(elem, attrValueObs, (val) => attrElem(elem, attrName, val));\n}\nexports.attr = attr;\n/**\n * Sets or removes a boolean attribute of a DOM element. According to the spec, empty string is a\n * valid true value for the attribute, and the false value is indicated by the attribute's absence.\n * The `boolAttr()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} attrName: The name of the attribute to bind, e.g. 'checked'.\n * @param {Boolean} boolValue: Boolean value whether to set or unset the attribute.\n */\nfunction boolAttrElem(elem, attrName, boolValue) {\n    attrElem(elem, attrName, boolValue ? '' : null);\n}\nexports.boolAttrElem = boolAttrElem;\nfunction boolAttr(attrName, boolValueObs) {\n    return (elem) => _subscribe(elem, boolValueObs, (val) => boolAttrElem(elem, attrName, val));\n}\nexports.boolAttr = boolAttr;\n/**\n * Adds a text node to the element. The `text()` variant takes no `elem`, and `value` may be an\n * observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} value: The text value to add.\n */\nfunction textElem(elem, value) {\n    elem.appendChild(browserGlobals_1.G.document.createTextNode(value));\n}\nexports.textElem = textElem;\nfunction text(valueObs) {\n    return (elem) => {\n        const textNode = browserGlobals_1.G.document.createTextNode('');\n        _subscribe(elem, valueObs, (val) => { textNode.nodeValue = val; });\n        elem.appendChild(textNode);\n    };\n}\nexports.text = text;\n/**\n * Sets a style property of a DOM element to the given value. The `style()` variant takes no\n * `elem`, and `value` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} property: The name of the style property to update, e.g. 'fontWeight'.\n * @param {String} value: The value for the property.\n */\nfunction styleElem(elem, property, value) {\n    elem.style[property] = value;\n}\nexports.styleElem = styleElem;\nfunction style(property, valueObs) {\n    return (elem) => _subscribe(elem, valueObs, (val) => styleElem(elem, property, val));\n}\nexports.style = style;\n/**\n * Sets the property of a DOM element to the given value.\n * The `prop()` variant takes no `elem`, and `value` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} property: The name of the property to update, e.g. 'disabled'.\n * @param {Object} value: The value for the property.\n */\nfunction propElem(elem, property, value) {\n    elem[property] = value;\n}\nexports.propElem = propElem;\nfunction prop(property, valueObs) {\n    return (elem) => _subscribe(elem, valueObs, (val) => propElem(elem, property, val));\n}\nexports.prop = prop;\n/**\n * Shows or hides the element depending on a boolean value. Note that the element must be visible\n * initially (i.e. unsetting style.display should show it).\n * The `show()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {Boolean} boolValue: True to show the element, false to hide it.\n */\nfunction showElem(elem, boolValue) {\n    elem.style.display = boolValue ? '' : 'none';\n}\nexports.showElem = showElem;\nfunction show(boolValueObs) {\n    return (elem) => _subscribe(elem, boolValueObs, (val) => showElem(elem, val));\n}\nexports.show = show;\n/**\n * The opposite of show, hiding the element when boolValue is true.\n * The `hide()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {Boolean} boolValue: True to hide the element, false to show it.\n */\nfunction hideElem(elem, boolValue) {\n    elem.style.display = boolValue ? 'none' : '';\n}\nexports.hideElem = hideElem;\nfunction hide(boolValueObs) {\n    return (elem) => _subscribe(elem, boolValueObs, (val) => hideElem(elem, val));\n}\nexports.hide = hide;\n/**\n * Toggles a css class `className` according to a boolean value.\n * The `toggleClass()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} className: The name of the class to toggle.\n * @param {Boolean} boolValue: Whether to add or remove the class.\n */\nfunction toggleClassElem(elem, className, boolValue) {\n    elem.classList.toggle(className, Boolean(boolValue));\n}\nexports.toggleClassElem = toggleClassElem;\nfunction toggleClass(className, boolValueObs) {\n    return (elem) => _subscribe(elem, boolValueObs, (val) => toggleClassElem(elem, className, val));\n}\nexports.toggleClass = toggleClass;\n/**\n * Adds a css class of the given name. A falsy name does not add any class. The `cssClass()`\n * variant takes no `elem`, and `className` may be an observable or function. In this case, when\n * the class name changes, the previously-set class name is removed.\n * @param {Element} elem: The element to update.\n * @param {String} className: The name of the class to add.\n */\nfunction cssClassElem(elem, className) {\n    if (className) {\n        elem.classList.add(className);\n    }\n}\nexports.cssClassElem = cssClassElem;\nfunction cssClass(classNameObs) {\n    return (elem) => {\n        let prevClass = null;\n        _subscribe(elem, classNameObs, (name) => {\n            if (prevClass) {\n                elem.classList.remove(prevClass);\n            }\n            prevClass = name;\n            if (name) {\n                elem.classList.add(name);\n            }\n        });\n    };\n}\nexports.cssClass = cssClass;\n/**\n * Associate arbitrary data with a DOM element. The `data()` variant takes no `elem`, and `value`\n * may be an observable or function.\n * @param {Element} elem: The element with which to associate data.\n * @param {String} key: Key to identify this piece of data among others attached to elem.\n * @param {Object} value: Arbitrary value to associate with elem.\n */\nfunction dataElem(elem, key, value) {\n    const obj = _dataMap.get(elem);\n    if (obj) {\n        obj[key] = value;\n    }\n    else {\n        _domDispose_1.onDisposeElem(elem, () => _dataMap.delete(elem));\n        _dataMap.set(elem, { [key]: value });\n    }\n}\nexports.dataElem = dataElem;\nfunction data(key, valueObs) {\n    return (elem) => _subscribe(elem, valueObs, (val) => dataElem(elem, key, val));\n}\nexports.data = data;\nfunction getData(elem, key) {\n    const obj = _dataMap.get(elem);\n    return obj && obj[key];\n}\nexports.getData = getData;\n// Helper for domComputed(); replace content between markerPre and markerPost with the given DOM\n// content, running disposers if any on the removed content.\nfunction _replaceContent(elem, markerPre, markerPost, content) {\n    if (markerPre.parentNode === elem) {\n        let next;\n        for (let n = markerPre.nextSibling; n && n !== markerPost; n = next) {\n            next = n.nextSibling;\n            _domDispose_1.domDispose(n);\n            elem.removeChild(n);\n        }\n        elem.insertBefore(_domImpl_1.frag(content), markerPost);\n    }\n}\nfunction domComputed(valueObs, contentFunc) {\n    const _contentFunc = contentFunc || identity;\n    return (elem) => {\n        const markerPre = browserGlobals_1.G.document.createComment('a');\n        const markerPost = browserGlobals_1.G.document.createComment('b');\n        elem.appendChild(markerPre);\n        elem.appendChild(markerPost);\n        _subscribe(elem, valueObs, (value) => _replaceContent(elem, markerPre, markerPost, _contentFunc(value)));\n    };\n}\nexports.domComputed = domComputed;\nfunction identity(arg) { return arg; }\n/**\n * Conditionally appends DOM to an element. The value may be an observable or function (from which\n * a computed is created), whose value -- if truthy -- will be passed to `contentFunc` which\n * should return DOM content. If the value is falsy, DOM content is removed.\n *\n * Note that if the observable changes between different truthy values, contentFunc gets called\n * for each value, and previous content gets destroyed. To consider all truthy values the same,\n * use an observable that returns a proper boolean, e.g.\n *\n *    dom.maybe(use => Boolean(use(fooObs)), () => dom(...));\n *\n * As with domComputed(), dom.maybe() may but should not be used when the argument is not an\n * observable or function. The following are equivalent:\n *\n *    dom(..., dom.maybe(myValue, () => dom(...)));\n *    dom(..., myValue ? dom(...) : null);\n *\n * The latter is preferred for being simpler.\n *\n * @param {Element} elem: The element to which to append the DOM content.\n * @param {Object} boolValueObs: Observable or function for a computed.\n * @param [Function] contentFunc: Function called with the result of boolValueObs when it is\n *    truthy. Should returning DOM as output.\n */\nfunction maybe(boolValueObs, contentFunc) {\n    return domComputed(boolValueObs, (value) => value ? contentFunc(value) : null);\n}\nexports.maybe = maybe;\n","\"use strict\";\n/**\n * binding.ts offers a convenient subscribe() function that creates a binding to an observable, a\n * a plain value, or a function from which it builds a computed.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst computed_1 = require(\"./computed\");\nconst observable_1 = require(\"./observable\");\n/**\n * Subscribes a callback to valueObs, which may be one a plain value, an observable, a knockout\n * observable, or a function. If a function, it's used to create a computed() and will be called\n * with a context function `use`, allowing it to depend on other observable values (see\n * documentation for `computed`).\n *\n * In all cases, `callback(newValue, oldValue)` is called immediately and whenever the value\n * changes. On the initial call, oldValue is undefined.\n *\n * Returns an object which should be disposed to remove the created subscriptions, or null.\n */\nfunction subscribe(valueObs, callback) {\n    // A plain function (to make a computed from), or a knockout observable.\n    if (typeof valueObs === 'function') {\n        // Knockout observable.\n        const koValue = valueObs;\n        if (typeof koValue.peek === 'function') {\n            let savedValue = koValue.peek();\n            const sub = koValue.subscribe((val) => {\n                const old = savedValue;\n                savedValue = val;\n                callback(val, old);\n            });\n            callback(savedValue, undefined);\n            return sub;\n        }\n        // Function from which to make a computed. Note that this is also reasonable:\n        //    let sub = subscribe(use => callback(valueObs(use)));\n        // The difference is that when valueObs() evaluates to unchanged value, callback would be\n        // called in the version above, but not in the version below.\n        const comp = computed_1.computed(valueObs);\n        comp.addListener(callback);\n        callback(comp.get(), undefined);\n        return comp; // Disposing this will dispose its one listener.\n    }\n    // An observable.\n    if (valueObs instanceof observable_1.Observable) {\n        const sub = valueObs.addListener(callback);\n        callback(valueObs.get(), undefined);\n        return sub;\n    }\n    callback(valueObs, undefined);\n    return null;\n}\nexports.subscribe = subscribe;\n","\"use strict\";\n/**\n * Module that allows client-side code to use browser globals (such as `document` or `Node`) in a\n * way that allows those globals to be replaced by mocks in browser-less tests.\n *\n *    import {G} from 'browserGlobals';\n *    ... use G.document\n *    ... use G.Node\n *\n * Initially, the global `window` object, is the source of the global values.\n *\n * To use a mock of globals in a test, use:\n *\n *    import {pushGlobals, popGlobals} as G from 'browserGlobals';\n *    before(function() {\n *      pushGlobals(mockWindow);    // e.g. jsdom.jsdom(...).defaultView\n *    });\n *    after(function() {\n *      popGlobals();\n *    });\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction _updateGlobals(dest, source) {\n    dest.DocumentFragment = source.DocumentFragment;\n    dest.Element = source.Element;\n    dest.Node = source.Node;\n    dest.document = source.document;\n    dest.window = source.window;\n}\n// The initial IBrowserGlobals object.\nconst initial = {};\n_updateGlobals(initial, (typeof window !== 'undefined' ? window : {}));\n// The globals G object strats out with a copy of `initial`.\nexports.G = Object.assign({}, initial);\n// The stack of globals that always has the intial object, but which may be overridden.\nconst _globalsStack = [initial];\n/**\n * Replace globals with those from the given object. Use popGlobals() to restore previous values.\n */\nfunction pushGlobals(globals) {\n    _globalsStack.push(globals);\n    _updateGlobals(exports.G, globals);\n}\nexports.pushGlobals = pushGlobals;\n/**\n * Restore the values of globals to undo the preceding pushGlobals() call.\n */\nfunction popGlobals() {\n    if (_globalsStack.length > 1) {\n        _globalsStack.pop();\n    }\n    _updateGlobals(exports.G, _globalsStack[_globalsStack.length - 1]);\n}\nexports.popGlobals = popGlobals;\n","\"use strict\";\n/**\n * computed.js implements a computed observable, whose value depends on other observables and gets\n * recalculated automatically when they change.\n *\n * E.g. if we have some existing observables (which may themselves be instances of `computed`),\n * we can create a computed that subscribes to them explicitly:\n *  let obs1 = observable(5), obs2 = observable(12);\n *  let computed1 = computed(obs1, obs2, (use, v1, v2) => v1 + v2);\n *\n * or implicitly by using `use(obs)` function:\n *  let computed2 = computed(use => use(obs1) + use(obs2));\n *\n * In either case, computed1.get() and computed2.get() will have the value 17. If obs1 or obs2 is\n * changed, computed1 and computed2 will get recomputed automatically.\n *\n * Creating a computed allows any number of dependencies to be specified explicitly, and their\n * values will be passed to the read() callback. These may be combined with automatic dependencies\n * detected using use(). Note that constructor dependencies have less overhead.\n *\n *  let val = computed(...deps, ((use, ...depValues) => READ_CALLBACK));\n *\n * You may specify a `write` callback by calling `onWrite(WRITE_CALLBACK)`, which will be called\n * whenever set() is called on the computed by its user. If a `write` bacllback is not specified,\n * calling `set` on a computed observable will throw an exception.\n *\n * Note that pureComputed.js offers a variation of computed() with the same interface, but which\n * stays unsubscribed from dependencies while it itself has no subscribers.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"./observable\");\nconst subscribe_1 = require(\"./subscribe\");\nfunction _noWrite() {\n    throw new Error(\"Can't write to non-writable computed\");\n}\nclass Computed extends observable_1.Observable {\n    /**\n     * Internal constructor for a Computed observable. You should use computed() function instead.\n     */\n    constructor(callback, dependencies) {\n        // At initialization we force an undefined value even though it's not of type T: it gets set\n        // to a proper value during the creation of new Subscription, which calls this._read.\n        super(undefined);\n        this._callback = callback;\n        this._write = _noWrite;\n        this._sub = new subscribe_1.Subscription(this._read.bind(this), dependencies);\n    }\n    /**\n     * Used by subscriptions to keep track of dependencies.\n     */\n    _getDepItem() {\n        return this._sub._getDepItem();\n    }\n    /**\n     * \"Sets\" the value of the computed by calling the write() callback if one was provided in the\n     * constructor. Throws an error if there was no such callback (not a \"writable\" computed).\n     * @param {Object} value: The value to pass to the write() callback.\n     */\n    set(value) { this._write(value); }\n    /**\n     * Set callback to call when this.set(value) is called, to make it a writable computed. If not\n     * set, attempting to write to this computed will throw an exception.\n     */\n    onWrite(writeFunc) {\n        this._write = writeFunc;\n        return this;\n    }\n    /**\n     * Disposes the computed, unsubscribing it from all observables it depends on.\n     */\n    dispose() {\n        this._sub.dispose();\n        super.dispose();\n    }\n    _read(use, ...args) {\n        super.set(this._callback(use, ...args));\n    }\n}\nexports.Computed = Computed;\n/**\n * Creates a new Computed.\n * @param {Observable} ...observables: The initial params, of which there may be zero or more, are\n *    observables on which this computed depends. When any of them change, the read() callback\n *    will be called with the values of these observables as arguments.\n * @param {Function} readCallback: Read callback that will be called with (use, ...values),\n *    i.e. the `use` function and values for all of the ...observables. The callback is called\n *    immediately and whenever any dependency changes.\n * @returns {Computed} The newly created computed observable.\n */\nfunction computed(...args) {\n    const readCb = args.pop();\n    return new Computed(readCb, args);\n}\nexports.computed = computed;\n// TODO Consider mplementing .singleUse() method.\n// An open question is in how to pass e.g. kd.hide(computed(x, x => !x)) in such a way that\n// the temporary computed can be disposed when temporary, but not otherwise. A function-only\n// syntax is kd.hide(use => !use(x)), but prevents use of static subscriptions.\n//\n// (a) function-only use of computeds is fine and useful.\n// (b) pureComputed is another option, and doesn't technically require getting disposed.\n// (c) kd.hide(compObs), kd.autoDispose(compObs) is more general and\n//     can be replaced more concisely by kd.hide(compObs.singleUse())\n// .singleUse() automatically disposes a computed (or an observable?) once there are no\n// subscriptions to it. If there are no subscriptions at the time of this call, waits for the next\n// tick, and possibly disposes then.\n","\"use strict\";\n/**\n * dispose.js provides tools to objects that needs to dispose resources, such as destroy DOM, and\n * unsubscribe from events. The motivation with examples is presented here:\n *\n *    https://phab.getgrist.com/w/disposal/\n *\n * Disposable is a class for components that need cleanup (e.g. maintain DOM, listen to\n * events, subscribe to anything). It provides a .dispose() method that should be called to\n * destroy the component, and .autoDispose() family of methods that the component should use to\n * take responsibility for other pieces that require cleanup.\n *\n * To define a disposable class:\n *    class Foo extends Disposable {\n *      create(...args) { ...constructor work... }      // Instead of constructor, if needed.\n *    }\n *\n * To create Foo:\n *    let foo = new Foo(args...);\n *\n * Foo should do constructor work in its create() method (or rarely other methods), where it can\n * take ownership of other objects:\n *    this.bar = this.autoDispose(new Bar(...));\n *\n * Note that create() is automatically called at construction. Its advantage is that if it throws\n * an exception, any calls to .autoDispose() that happened before the exception are honored.\n *\n * For more customized disposal:\n *    this.baz = this.autoDisposeWithMethod('destroy', new Baz());\n *    this.elem = this.autoDisposeWith(ko.cleanNode, document.createElement(...));\n * When `this` is disposed, it will call this.baz.destroy(), and ko.cleanNode(this.elem).\n *\n * To call another method on disposal (e.g. to add custom disposal logic):\n *    this.autoDisposeCallback(this.myUnsubscribeAllMethod);\n * The method will be called with `this` as context, and no arguments.\n *\n * To wipe out this object on disposal (i.e. set all properties to null):\n *    this.wipeOnDispose();\n * See the documentation of that method for more info.\n *\n * To dispose Foo:\n *    foo.dispose();\n * Owned objects will be disposed in reverse order from which `autoDispose` were called.\n *\n * To release an owned object:\n *    this.disposeRelease(this.bar);\n *\n * To dispose an owned object early:\n *    this.disposeDiscard(this.bar);\n *\n * To determine if an object has already been disposed:\n *    foo.isDisposed()\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Disposable {\n    /**\n     * Constructor forwards arguments to  `this.create(...args)`, which is where subclasses should\n     * do any constructor work. This ensures that if create() throws an exception, dispose() gets\n     * called to clean up the partially-constructed object.\n     */\n    constructor(...args) {\n        this._disposalList = [];\n        try {\n            this.create(...args);\n        }\n        catch (e) {\n            try {\n                this.dispose();\n            }\n            catch (e) {\n                // tslint:disable-next-line:no-console\n                console.error(\"Error disposing partially constructed %s:\", this.constructor.name, e);\n            }\n            throw e;\n        }\n    }\n    /**\n     * Take ownership of `obj`, and dispose it when `this.dispose` is called.\n     * @param {Object} obj: Disposable object to take ownership of.\n     * @returns {Object} obj\n     */\n    autoDispose(obj) {\n        return this.autoDisposeWith(_defaultDisposer, obj);\n    }\n    /**\n     * Take ownership of `obj`, and dispose it by calling the specified function.\n     * @param {Function} disposer: disposer(obj) will be called to dispose the object, with `this`\n     *    as the context.\n     * @param {Object} obj: Object to take ownership of, on which `disposer` will be called.\n     * @returns {Object} obj\n     */\n    autoDisposeWith(disposer, obj) {\n        this._disposalList.push({ obj, disposer });\n        return obj;\n    }\n    /**\n     * Take ownership of `obj`, and dispose it with `obj[methodName]()`.\n     * @param {String} methodName: method name to call on obj when it's time to dispose it.\n     * @returns {Object} obj\n     */\n    autoDisposeWithMethod(methodName, obj) {\n        return this.autoDisposeWith((_obj) => _obj[methodName](), obj);\n    }\n    /**\n     * Adds the given callback to be called when `this.dispose` is called.\n     * @param {Function} callback: Called on disposal with `this` as the context and no arguments.\n     * @returns nothing\n     */\n    autoDisposeCallback(callback) {\n        this.autoDisposeWith(_callFuncHelper, callback);\n    }\n    /**\n     * Wipe out this object when it is disposed, i.e. set all its properties to null. It is\n     * recommended to call this early in the constructor. It's safe to call multiple times.\n     *\n     * This makes disposal more costly, but has certain benefits:\n     * - If anything still refers to the object and uses it, we'll get an early error, rather than\n     *   silently keep going, potentially doing useless work (or worse) and wasting resources.\n     * - If anything still refers to the object (even without using it), the fields of the object\n     *   can still be garbage-collected.\n     * - If there are circular references involving this object, they get broken, making the job\n     *   easier for the garbage collector.\n     *\n     * The recommendation is to use it for complex, longer-lived objects, but to skip for objects\n     * which are numerous and short-lived (and less likely to be referenced from unexpected places).\n     */\n    wipeOnDispose() {\n        this.autoDisposeWith(_wipeOutObject, this);\n    }\n    /**\n     * Remove `obj` from the list of owned objects; it will not be disposed on `this.dispose`.\n     * @param {Object} obj: Object to release.\n     * @returns {Object} obj\n     */\n    disposeRelease(obj) {\n        const list = this._disposalList;\n        const index = list.findIndex((entry) => (entry.obj === obj));\n        if (index !== -1) {\n            list.splice(index, 1);\n        }\n        return obj;\n    }\n    /**\n     * Dispose an owned object `obj` now, and remove it from the list of owned objects.\n     * @param {Object} obj: Object to release.\n     * @returns nothing\n     */\n    disposeDiscard(obj) {\n        const list = this._disposalList;\n        const index = list.findIndex((entry) => (entry.obj === obj));\n        if (index !== -1) {\n            const entry = list[index];\n            list.splice(index, 1);\n            entry.disposer.call(this, obj);\n        }\n    }\n    /**\n     * Returns whether this object has already been disposed.\n     */\n    isDisposed() {\n        return this._disposalList === null;\n    }\n    /**\n     * Clean up `this` by disposing all owned objects, and calling `stopListening()` if defined.\n     */\n    dispose() {\n        const list = this._disposalList;\n        if (list) {\n            // This makes isDisposed() true, and the object is no longer valid (in particular,\n            // this._disposalList no longer satisfies its declared type).\n            this._disposalList = null;\n            // Go backwards through the disposal list, and dispose everything.\n            for (let i = list.length - 1; i >= 0; i--) {\n                const entry = list[i];\n                _disposeHelper(this, entry.disposer, entry.obj);\n            }\n        }\n    }\n}\nexports.Disposable = Disposable;\n/**\n * Internal helper to allow adding cleanup callbacks to the disposalList. It acts as the\n * \"disposer\" for callback, by simply calling them with the same context that it is called with.\n */\nfunction _callFuncHelper(callback) {\n    callback.call(this);\n}\n/**\n * Wipe out the given object by setting each property to a dummy sentinel value. This is helpful\n * for objects that are disposed and should be ready to be garbage-collected.\n *\n * The sentinel value doesn't have to be null, but some values cause more helpful errors than\n * others. E.g. if a.x = \"disposed\", then a.x.foo() throws \"undefined is not a function\", while\n * when a.x = null, a.x.foo() throws \"Cannot read property 'foo' of null\", which is more helpful.\n */\nfunction _wipeOutObject(obj) {\n    Object.keys(obj).forEach((k) => (obj[k] = null));\n}\n/**\n * Internal helper to call a disposer on an object. It swallows errors (but reports them) to make\n * sure that when we dispose an object, an error in disposing one owned part doesn't stop\n * the disposal of the other parts.\n */\nfunction _disposeHelper(owner, disposer, obj) {\n    try {\n        disposer.call(owner, obj);\n    }\n    catch (e) {\n        // tslint:disable-next-line:no-console\n        console.error(\"While disposing %s, error disposing %s: %s\", _describe(owner), _describe(obj), e);\n    }\n}\n/**\n * Helper for reporting errors during disposal. Try to report the type of the object.\n */\nfunction _describe(obj) {\n    return (obj && obj.constructor && obj.constructor.name ? obj.constructor.name : '' + obj);\n}\n/**\n * Helper disposer that simply invokes the .dispose() method.\n */\nfunction _defaultDisposer(obj) {\n    obj.dispose();\n}\n","\"use strict\";\n/**\n * dom.js provides a way to build a DOM tree easily.\n *\n * E.g.\n *  import {dom} from 'grainjs';\n *  dom('a#link.c1.c2', {'href': url}, 'Hello ', dom('span', 'world'));\n *    creates Node <a id=\"link\" class=\"c1 c2\" href={{url}}Hello <span>world</span></a>.\n *\n *  dom.frag(dom('span', 'Hello'), ['blah', dom('div', 'world')])\n *    creates document fragment with <span>Hello</span>blah<div>world</div>.\n *\n * DOM can also be created and modified inline during creation:\n *  dom('a#id.c1',\n *      dom.cssClass('c2'), dom.attr('href', url),\n *      dom.text('Hello '), dom('span', dom.text('world')))\n *    creates Node <a id=\"link\" class=\"c1 c2\" href={{url}}Hello <span>world</span></a>,\n *    identical to the first example above.\n */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// We keep various dom-related functions organized in private modules, but they are exposed here.\nvar _domImpl_1 = require(\"./_domImpl\");\nexports.svg = _domImpl_1.svg;\nexports.update = _domImpl_1.update;\nexports.frag = _domImpl_1.frag;\nexports.find = _domImpl_1.find;\nexports.findAll = _domImpl_1.findAll;\n__export(require(\"./_domComponent\"));\n__export(require(\"./_domDispose\"));\n__export(require(\"./_domMethods\"));\n__export(require(\"./domevent\"));\nconst _domComponent = require(\"./_domComponent\");\nconst _domDispose = require(\"./_domDispose\");\nconst _domImpl = require(\"./_domImpl\");\nconst _domMethods = require(\"./_domMethods\");\nconst domevent = require(\"./domevent\");\n// We just want to re-export _domImpl.dom, but to allow adding methods to it in a typesafe way,\n// TypeScript wants us to declare a real function in the same file.\nfunction dom(tagString, ...args) {\n    return _domImpl.dom(tagString, ...args);\n}\nexports.dom = dom;\n// Additionally export all methods as properties of dom() function.\n(function (dom) {\n    dom.svg = _domImpl.svg;\n    dom.frag = _domImpl.frag;\n    dom.update = _domImpl.update;\n    dom.find = _domImpl.find;\n    dom.findAll = _domImpl.findAll;\n    dom.domDispose = _domDispose.domDispose;\n    dom.onDisposeElem = _domDispose.onDisposeElem;\n    dom.onDispose = _domDispose.onDispose;\n    dom.autoDisposeElem = _domDispose.autoDisposeElem;\n    dom.autoDispose = _domDispose.autoDispose;\n    dom.attrsElem = _domMethods.attrsElem;\n    dom.attrs = _domMethods.attrs;\n    dom.attrElem = _domMethods.attrElem;\n    dom.attr = _domMethods.attr;\n    dom.boolAttrElem = _domMethods.boolAttrElem;\n    dom.boolAttr = _domMethods.boolAttr;\n    dom.textElem = _domMethods.textElem;\n    dom.text = _domMethods.text;\n    dom.styleElem = _domMethods.styleElem;\n    dom.style = _domMethods.style;\n    dom.propElem = _domMethods.propElem;\n    dom.prop = _domMethods.prop;\n    dom.showElem = _domMethods.showElem;\n    dom.show = _domMethods.show;\n    dom.hideElem = _domMethods.hideElem;\n    dom.hide = _domMethods.hide;\n    dom.toggleClassElem = _domMethods.toggleClassElem;\n    dom.toggleClass = _domMethods.toggleClass;\n    dom.cssClassElem = _domMethods.cssClassElem;\n    dom.cssClass = _domMethods.cssClass;\n    dom.dataElem = _domMethods.dataElem;\n    dom.data = _domMethods.data;\n    dom.getData = _domMethods.getData;\n    dom.domComputed = _domMethods.domComputed;\n    dom.maybe = _domMethods.maybe;\n    dom.Component = _domComponent.Component;\n    dom.createElem = _domComponent.createElem;\n    dom.create = _domComponent.create;\n    dom.createInit = _domComponent.createInit;\n    dom.onElem = domevent.onElem;\n    dom.on = domevent.on;\n    dom.onMatchElem = domevent.onMatchElem;\n    dom.onMatch = domevent.onMatch;\n})(dom = exports.dom || (exports.dom = {}));\n","\"use strict\";\n/**\n * domevent provides a way to listen to DOM events, similar to JQuery's `on()` function. Its\n * methods are also exposed via the dom.js module, as `dom.on()`, etc.\n *\n * It is typically used as an argument to the dom() function:\n *\n *    dom('div', dom.on('click', (event, elem) => { ... }));\n *\n * When the div is disposed, the listener is automatically removed.\n *\n * The underlying interface to listen to an event is this:\n *\n *    let listener = dom.onElem(elem, 'click', (event, elem) => { ... });\n *\n * The callback is called with the event and the element to which it was attached. Unlike in\n * JQuery, the callback's return value is ignored. Use event.stopPropagation() and\n * event.preventDefault() explicitly if needed.\n *\n * To stop listening:\n *\n *    listener.dispose();\n *\n * Disposing the listener returned by .on() is the only way to stop listening to an event. You can\n * use autoDispose to stop listening automatically when subscribing in a Disposable object:\n *\n *    this.autoDispose(domevent.on(document, 'mouseup', callback));\n *\n * To listen to descendants of an element matching the given selector (what JQuery calls\n * \"delegated events\", see http://api.jquery.com/on/):\n *\n *    dom('div', dom.onMatch('.selector', 'click', (event, elem) => { ... }));\n * or\n *    let lis = domevent.onMatchElem(elem, '.selector', 'click', (event, el) => { ... });\n *\n * In this usage, the element passed to the callback will be a DOM element matching the given\n * selector. If there are multiple matches, the callback is only called for the innermost one.\n *\n * If you need to remove the callback on first call, here's a useful pattern:\n *    let lis = domevent.onElem(elem, 'mouseup', e => { lis.dispose(); other_work(); });\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction _findMatch(inner, outer, selector) {\n    for (let el = inner; el && el !== outer; el = el.parentElement) {\n        if (el.matches(selector)) {\n            return el;\n        }\n    }\n    return null;\n}\nclass DomEventListener {\n    constructor(elem, eventType, callback, useCapture, selector) {\n        this.elem = elem;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.useCapture = useCapture;\n        this.selector = selector;\n        this.elem.addEventListener(this.eventType, this, this.useCapture);\n    }\n    handleEvent(event) {\n        const cb = this.callback;\n        cb(event, this.elem);\n    }\n    dispose() {\n        this.elem.removeEventListener(this.eventType, this, this.useCapture);\n    }\n}\nclass DomEventMatchListener extends DomEventListener {\n    handleEvent(event) {\n        const elem = _findMatch(event.target, this.elem, this.selector);\n        if (elem) {\n            const cb = this.callback;\n            cb(event, elem);\n        }\n    }\n}\n/**\n * Listen to a DOM event. The `on()` variant takes no `elem` argument, and may be used as an\n * argument to dom() function.\n * @param {DOMElement} elem: DOM Element to listen to.\n * @param {String} eventType: Event type to listen for (e.g. 'click').\n * @param {Function} callback: Callback to call as `callback(event, elem)`, where elem is `elem`.\n * @param [Boolean] options.useCapture: Add the listener in the capture phase. This should very\n *    rarely be useful (e.g. JQuery doesn't even offer it as an option).\n * @returns {Object} Listener object whose .dispose() method will remove the event listener.\n */\nfunction onElem(elem, eventType, callback, { useCapture = false } = {}) {\n    return new DomEventListener(elem, eventType, callback, useCapture);\n}\nexports.onElem = onElem;\nfunction on(eventType, callback, { useCapture = false } = {}) {\n    return (elem) => new DomEventListener(elem, eventType, callback, useCapture);\n}\nexports.on = on;\n/**\n * Listen to a DOM event on descendants of the given elem matching the given selector. The\n * `onMatch()` variant takes no `elem` argument, and may be used as an argument to dom().\n * @param {DOMElement} elem: DOM Element to whose descendants to listen.\n * @param {String} selector: CSS selector string to filter elements that trigger this event.\n *    JQuery calls it \"delegated events\" (http://api.jquery.com/on/). The callback will only be\n *    called when the event occurs for an element matching the given selector. If there are\n *    multiple elements matching the selector, the callback is only called for the innermost one.\n * @param {String} eventType: Event type to listen for (e.g. 'click').\n * @param {Function} callback: Callback to call as `callback(event, elem)`, where elem is a\n *    descendent of `elem` which matches `selector`.\n * @param [Boolean] options.useCapture: Add the listener in the capture phase. This should very\n *    rarely be useful (e.g. JQuery doesn't even offer it as an option).\n * @returns {Object} Listener object whose .dispose() method will remove the event listener.\n */\nfunction onMatchElem(elem, selector, eventType, callback, { useCapture = false } = {}) {\n    return new DomEventMatchListener(elem, eventType, callback, useCapture, selector);\n}\nexports.onMatchElem = onMatchElem;\nfunction onMatch(selector, eventType, callback, { useCapture = false } = {}) {\n    return (elem) => new DomEventMatchListener(elem, eventType, callback, useCapture, selector);\n}\nexports.onMatch = onMatch;\n","\"use strict\";\n/**\n * emit.js implements an Emitter class which emits events to a list of listeners. Listeners are\n * simply functions to call, and \"emitting an event\" just calls those functions.\n *\n * This is similar to Backbone events, with more focus on efficiency. Both inserting and removing\n * listeners is constant time.\n *\n * To create an emitter:\n *    let emitter = new Emitter();\n *\n * To add a listener:\n *    let listener = fooEmitter.addListener(callback);\n * To remove a listener:\n *    listener.dispose();\n *\n * The only way to remove a listener is to dispose the Listener object returned by addListener().\n * You can often use autoDispose to do this automatically when subscribing in a constructor:\n *    this.autoDispose(fooEmitter.addListener(this.onFoo, this));\n *\n * To emit an event, call emit() with any number of arguments:\n *    emitter.emit(\"hello\", \"world\");\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Note about a possible alternative implementation.\n//\n// We could implement the same interface using an array of listeners. Certain issues apply, in\n// particular with removing listeners from inside emit(), and in ensuring that removals are\n// constant time on average. Such an implementation was attempted and timed. The result is that\n// compared to the linked-list implementation here, add/remove combination could be made nearly\n// twice faster (on average), while emit and add/remove/emit are consistently slightly slower.\n//\n// The implementation here was chosen based on those timings, and as the simpler one. For example,\n// on one setup (macbook, node4, 5-listener queue), add+remove take 0.1us, while add+remove+emit\n// take 3.82us. (In array-based implementation with same set up, add+remove is 0.06us, while\n// add+remove+emit is 4.80us.)\n// The private property name to hold next/prev pointers.\nfunction _noop() { }\n/**\n * This is an implementation of a doubly-linked list, with just the minimal functionality we need.\n */\nclass LLink {\n    constructor() {\n        this._next = null;\n        this._prev = null;\n        // This immediate circular reference might be undesirable for GC, but might not matter, and\n        // makes the linked list implementation simpler and faster.\n        this._next = this;\n        this._prev = this;\n    }\n    isDisposed() {\n        return !this._next;\n    }\n    _insertBefore(next, node) {\n        const last = next._prev;\n        last._next = node;\n        next._prev = node;\n        node._prev = last;\n        node._next = next;\n    }\n    _removeNode(node) {\n        if (node._prev) {\n            node._prev._next = node._next;\n            node._next._prev = node._prev;\n        }\n        node._prev = node._next = null;\n    }\n    _disposeList() {\n        let node = this;\n        let next = node._next;\n        while (next !== null) {\n            node._next = node._prev = null;\n            node = next;\n            next = node._next;\n        }\n    }\n}\nexports.LLink = LLink;\nclass Emitter extends LLink {\n    /**\n     * Constructs an Emitter object.\n     */\n    constructor() {\n        super();\n        this._changeCB = _noop;\n        this._changeCBContext = undefined;\n    }\n    /**\n     * Adds a listening callback to the list of functions to call on emit().\n     * @param {Function} callback: Function to call.\n     * @param {Object} optContext: Context for the function.\n     * @returns {Listener} Listener object. Its dispose() method removes the callback from the list.\n     */\n    addListener(callback, optContext) {\n        return new Listener(this, callback, optContext);\n    }\n    /**\n     * Calls all listener callbacks, passing all arguments to each of them.\n     */\n    emit(...args) {\n        Listener.callAll(this._next, this, args);\n    }\n    /**\n     * Sets the single callback that would get called when a listener is added or removed.\n     * @param {Function} changeCB(hasListeners): Function to call after a listener is added or\n     *    removed. It's called with a boolean indicating whether this Emitter has any listeners.\n     *    Pass in `null` to unset the callback.\n     */\n    setChangeCB(changeCB, optContext) {\n        this._changeCB = changeCB || _noop;\n        this._changeCBContext = optContext;\n    }\n    /**\n     * Helper used by Listener class, but not intended for public usage.\n     */\n    _triggerChangeCB() {\n        this._changeCB.call(this._changeCBContext, this.hasListeners());\n    }\n    /**\n     * Returns whether this Emitter has any listeners.\n     */\n    hasListeners() {\n        return this._next !== this;\n    }\n    /**\n     * Disposes the Emitter. It breaks references between the emitter and all the items, allowing\n     * for better garbage collection. It effectively disposes all current listeners.\n     */\n    dispose() {\n        this._disposeList();\n        this._changeCB = _noop;\n        this._changeCBContext = undefined;\n    }\n}\nexports.Emitter = Emitter;\n/**\n * Listener object wraps a callback added to an Emitter, allowing for O(1) removal when the\n * listener is disposed.\n */\nclass Listener extends LLink {\n    constructor(emitter, callback, context) {\n        super();\n        this.emitter = emitter;\n        this.callback = callback;\n        this.context = context;\n        this._insertBefore(emitter, this);\n        emitter._triggerChangeCB();\n    }\n    static callAll(begin, end, args) {\n        while (begin !== end) {\n            const lis = begin;\n            lis.callback.call(lis.context, ...args);\n            begin = lis._next;\n        }\n    }\n    dispose() {\n        if (this.isDisposed()) {\n            return;\n        }\n        this._removeNode(this);\n        this.emitter._triggerChangeCB();\n    }\n}\nexports.Listener = Listener;\n","\"use strict\";\n/**\n * Grain.js observables and computeds are similar to (and mostly inspired by) those in\n * Knockout.js. In fact, they can work together.\n *\n *  import {fromKo} from 'kowrap'\n *\n *  fromKo(koObservable)\n *\n * returns a Grain.js observable that mirrors the passed-in Knockout observable (which may be a\n * computed as well). Similarly,\n *\n *  import {toKo} from 'kowrap';\n *  import * as ko from 'knockout';\n *\n *  toKo(ko, observable)\n *\n * returns a Knockout.js observable that mirrows the passed-in Grain observable or computed. Note\n * that toKo() mus tbe called with the knockout module as an argument. This is to avoid adding\n * knockout as a dependency of grainjs.\n *\n * In both cases, calling fromKo/toKo twice on the same observable will return the same wrapper,\n * and subscriptions and disposal are appropriately set up to make usage seamless.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst observable_1 = require(\"./observable\");\nconst fromKoWrappers = new WeakMap();\nconst toKoWrappers = new WeakMap();\n/**\n * Returns a Grain.js observable which mirrors a Knockout observable.\n */\nfunction fromKo(koObservable) {\n    const prevObs = fromKoWrappers.get(koObservable);\n    if (prevObs) {\n        return prevObs;\n    }\n    const newObs = observable_1.observable(koObservable.peek());\n    fromKoWrappers.set(koObservable, newObs);\n    koObservable.subscribe((val) => newObs.set(val));\n    return newObs;\n}\nexports.fromKo = fromKo;\n/**\n * Returns a Knockout observable which mirrors a Grain.js observable.\n */\nfunction toKo(knockout, grainObs) {\n    const prevKoObs = toKoWrappers.get(grainObs);\n    if (prevKoObs) {\n        return prevKoObs;\n    }\n    const newKoObs = knockout.observable(grainObs.get());\n    toKoWrappers.set(grainObs, newKoObs);\n    grainObs.addListener((val) => newKoObs(val));\n    return newKoObs;\n}\nexports.toKo = toKo;\n","\"use strict\";\n/**\n * observable.js implements an observable value, which lets other code subscribe to changes.\n *\n * E.g.\n *  let o = observable(17);\n *  o.get();          // 17\n *  o.addListener(foo);\n *  o.set(\"asdf\");    // foo(\"asdf\", 17) gets called.\n *  o.get();          // \"asdf\"\n *\n * To subscribe to changes, use obs.addListener(callback, context). The callback will get called\n * with (newValue, oldValue) as arguments.\n *\n * When you use observables within the body of a computed(), you can automatically create\n * subscriptions to them with the use(obs) function. E.g.\n *    let obs3 = computed(use => use(obs1) + use(obs2));\n * creates a computed observable `obs3` which is subscribed to changes to `obs1` and `obs2`.\n *\n * Note that unlike with knockout, use(obs) method requires an explicit `use` function, which is\n * always passed to a computed's read() callback for this purpose. This makes it explicit when a\n * dependency is created, and which observables the dependency connects.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _computed_queue_1 = require(\"./_computed_queue\");\nconst emit_1 = require(\"./emit\");\nvar _computed_queue_2 = require(\"./_computed_queue\");\nexports.bundleChanges = _computed_queue_2.bundleChanges;\nclass Observable {\n    /**\n     * Internal constructor for an Observable. You should use observable() function instead.\n     */\n    constructor(value) {\n        this._onChange = new emit_1.Emitter();\n        this._value = value;\n    }\n    /**\n     * Returns the value of the observable. It is fast and does not create a subscription.\n     * (It is similar to knockout's peek()).\n     * @returns {Object} The current value of the observable.\n     */\n    get() { return this._value; }\n    /**\n     * Sets the value of the observable. If the value differs from the previously set one, then\n     * listeners to this observable will get called with (newValue, oldValue) as arguments.\n     * @param {Object} value: The new value to set.\n     */\n    set(value) {\n        const prev = this._value;\n        if (value !== prev) {\n            this._value = value;\n            this._onChange.emit(value, prev);\n            _computed_queue_1.compute();\n        }\n    }\n    /**\n     * Adds a callback to listen to changes in the observable.\n     * @param {Function} callback: Function, called on changes with (newValue, oldValue) arguments.\n     * @param {Object} optContext: Context for the function.\n     * @returns {Listener} Listener object. Its dispose() method removes the callback.\n     */\n    addListener(callback, optContext) {\n        return this._onChange.addListener(callback, optContext);\n    }\n    /**\n     * Returns whether this observable has any listeners.\n     */\n    hasListeners() {\n        return this._onChange.hasListeners();\n    }\n    /**\n     * Sets a single callback to be called when a listener is added or removed. It overwrites any\n     * previously-set such callback.\n     * @param {Function} changeCB(hasListeners): Function to call after a listener is added or\n     *    removed. It's called with a boolean indicating whether this observable has any listeners.\n     *    Pass in `null` to unset the callback.\n     */\n    setListenerChangeCB(changeCB, optContext) {\n        this._onChange.setChangeCB(changeCB, optContext);\n    }\n    /**\n     * Used by subscriptions to keep track of dependencies. An observable that has dependnecies,\n     * such as a computed observable, would override this method.\n     */\n    _getDepItem() {\n        return null;\n    }\n    /**\n     * Disposes the observable.\n     */\n    dispose() {\n        this._onChange.dispose();\n        this._value = undefined;\n    }\n    /**\n     * Returns whether this observable is disposed.\n     */\n    isDisposed() {\n        return this._onChange.isDisposed();\n    }\n}\nexports.Observable = Observable;\n/**\n * Creates a new Observable with the initial value of optValue if given or undefined if omitted.\n * @param {Object} optValue: The initial value to set.\n * @returns {Observable} The newly created observable.\n */\nfunction observable(value) {\n    return new Observable(value);\n}\nexports.observable = observable;\n","\"use strict\";\n/**\n * subscribe.js implements subscriptions to several observables at once.\n *\n * E.g. if we have some existing observables (which may be instances of `computed`),\n * we can subscribe to them explicitly:\n *    let obs1 = observable(5), obs2 = observable(12);\n *    subscribe(obs1, obs2, (use, v1, v2) => console.log(v1, v2));\n *\n * or implicitly by using `use(obs)` function, which allows dynamic subscriptions:\n *    subscribe(use => console.log(use(obs1), use(obs2)));\n *\n * In either case, if obs1 or obs2 is changed, the callbacks will get called automatically.\n *\n * Creating a subscription allows any number of dependencies to be specified explicitly, and their\n * values will be passed to the callback(). These may be combined with automatic dependencies\n * detected using use(). Note that constructor dependencies have less overhead.\n *\n *    subscribe(...deps, ((use, ...depValues) => READ_CALLBACK));\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst _computed_queue_1 = require(\"./_computed_queue\");\n// Constant empty array, which we use to avoid allocating new read-only empty arrays.\nconst emptyArray = [];\nclass Subscription {\n    /**\n     * Internal constructor for a Subscription. You should use subscribe() function instead.\n     */\n    constructor(callback, dependencies) {\n        this._depItem = new _computed_queue_1.DepItem(this._evaluate, this);\n        this._dependencies = dependencies.length > 0 ? dependencies : emptyArray;\n        this._depListeners = dependencies.length > 0 ? dependencies.map((obs) => this._subscribeTo(obs)) : emptyArray;\n        this._dynDeps = new Map(); // Maps dependent observable to its Listener object.\n        this._callback = callback;\n        this._useFunc = this._useDependency.bind(this);\n        this._evaluate();\n    }\n    /**\n     * Disposes the computed, unsubscribing it from all observables it depends on.\n     */\n    dispose() {\n        for (const lis of this._depListeners) {\n            lis.dispose();\n        }\n        for (const lis of this._dynDeps.values()) {\n            lis.dispose();\n        }\n    }\n    /**\n     * For use by computed(): returns this subscription's hook into the _computed_queue.\n     */\n    _getDepItem() { return this._depItem; }\n    /**\n     * @private\n     * Gets called when the callback calls `use(obs)` for an observable. It creates a\n     * subscription to `obs` if one doesn't yet exist.\n     * @param {Observable} obs: The observable being used as a dependency.\n     */\n    _useDependency(obs) {\n        let listener = this._dynDeps.get(obs);\n        if (!listener) {\n            listener = this._subscribeTo(obs);\n            this._dynDeps.set(obs, listener);\n        }\n        listener._inUse = true;\n        this._depItem.useDep(obs._getDepItem());\n        return obs.get();\n    }\n    /**\n     * @private\n     * Calls the callback() with appropriate args, and updates subscriptions when it is done.\n     * I.e. adds dynamic subscriptions created via `use(obs)`, and disposes those no longer used.\n     */\n    _evaluate() {\n        try {\n            // Note that this is faster than using .map().\n            const readArgs = [this._useFunc];\n            for (let i = 0, len = this._dependencies.length; i < len; i++) {\n                readArgs[i + 1] = this._dependencies[i].get();\n                this._depItem.useDep(this._dependencies[i]._getDepItem());\n            }\n            return this._callback.apply(undefined, readArgs);\n        }\n        finally {\n            this._dynDeps.forEach((listener, obs) => {\n                if (listener._inUse) {\n                    listener._inUse = false;\n                }\n                else {\n                    this._dynDeps.delete(obs);\n                    listener.dispose();\n                }\n            });\n        }\n    }\n    /**\n     * @private\n     * Subscribes this computed to another observable that it depends on.\n     * @param {Observable} obs: The observable to subscribe to.\n     * @returns {Listener} Listener object.\n     */\n    _subscribeTo(obs) {\n        return obs.addListener(this._enqueue, this);\n    }\n    /**\n     * @private\n     * Adds this item to the recompute queue.\n     */\n    _enqueue() {\n        this._depItem.enqueue();\n    }\n}\nexports.Subscription = Subscription;\n/**\n * Creates a new Subscription.\n * @param {Observable} ...observables: The initial params, of which there may be zero or more, are\n *    observables on which this computed depends. When any of them change, the callback()\n *    will be called with the values of these observables as arguments.\n * @param {Function} callback: will be called with arguments (use, ...values), i.e. the\n *    `use` function and values for all of the ...observables that precede this argument.\n *    This callback is called immediately, and whenever any dependency changes.\n * @returns {Subscription} The new subscription which may be disposed to unsubscribe.\n */\nfunction subscribe(...args) {\n    const cb = args.pop();\n    // The cast helps ensure that Observable is compatible with ISubscribable abstraction that we use.\n    return new Subscription(cb, args);\n}\nexports.subscribe = subscribe;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns f such that f() calls func(...boundArgs), i.e. optimizes `() => func(...boundArgs)`.\n * It is faster on node6 by 57-92%.\n */\nfunction bindB(func, b) {\n    switch (b.length) {\n        case 0: return () => func();\n        case 1: return () => func(b[0]);\n        case 2: return () => func(b[0], b[1]);\n        case 3: return () => func(b[0], b[1], b[2]);\n        case 4: return () => func(b[0], b[1], b[2], b[3]);\n        case 5: return () => func(b[0], b[1], b[2], b[3], b[4]);\n        case 6: return () => func(b[0], b[1], b[2], b[3], b[4], b[5]);\n        case 7: return () => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6]);\n        case 8: return () => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\n        default: return () => func.apply(undefined, b);\n    }\n}\nexports.bindB = bindB;\n/**\n * Returns f such that f(unboundArg) calls func(unboundArg, ...boundArgs).\n * I.e. optimizes `(arg) => func(arg, ...boundArgs)`.\n * It is faster on node6 by 0-92%.\n */\nfunction bindUB(func, b) {\n    switch (b.length) {\n        case 0: return (arg) => func(arg);\n        case 1: return (arg) => func(arg, b[0]);\n        case 2: return (arg) => func(arg, b[0], b[1]);\n        case 3: return (arg) => func(arg, b[0], b[1], b[2]);\n        case 4: return (arg) => func(arg, b[0], b[1], b[2], b[3]);\n        case 5: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4]);\n        case 6: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4], b[5]);\n        case 7: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4], b[5], b[6]);\n        case 8: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\n        default: return (arg) => func(arg, ...b);\n    }\n}\nexports.bindUB = bindUB;\n/**\n * Returns f such that f(unboundArg) calls func(...boundArgs, unboundArg).\n * I.e. optimizes `(arg) => func(...boundArgs, arg)`.\n * It is faster on node6 by 0-92%.\n */\nfunction bindBU(func, b) {\n    switch (b.length) {\n        case 0: return (arg) => func(arg);\n        case 1: return (arg) => func(b[0], arg);\n        case 2: return (arg) => func(b[0], b[1], arg);\n        case 3: return (arg) => func(b[0], b[1], b[2], arg);\n        case 4: return (arg) => func(b[0], b[1], b[2], b[3], arg);\n        case 5: return (arg) => func(b[0], b[1], b[2], b[3], b[4], arg);\n        case 6: return (arg) => func(b[0], b[1], b[2], b[3], b[4], b[5], arg);\n        case 7: return (arg) => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6], arg);\n        case 8: return (arg) => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], arg);\n        default: return (arg) => func(...b, arg);\n    }\n}\nexports.bindBU = bindBU;\n","/**\n * FastPriorityQueue.js : a fast heap-based priority queue  in JavaScript.\n * (c) the authors\n * Licensed under the Apache License, Version 2.0.\n *\n * Speed-optimized heap-based priority queue for modern browsers and JavaScript engines.\n *\n * Usage :\n         Installation (in shell, if you use node):\n         $ npm install fastpriorityqueue\n\n         Running test program (in JavaScript):\n\n         // var FastPriorityQueue = require(\"fastpriorityqueue\");// in node\n         var x = new FastPriorityQueue();\n         x.add(1);\n         x.add(0);\n         x.add(5);\n         x.add(4);\n         x.add(3);\n         x.peek(); // should return 0, leaves x unchanged\n         x.size; // should return 5, leaves x unchanged\n         while(!x.isEmpty()) {\n           console.log(x.poll());\n         } // will print 0 1 3 4 5\n         x.trim(); // (optional) optimizes memory usage\n */\n\"use strict\";\n\nvar defaultcomparator = function (a, b) {\n    return a < b;\n};\n\n// the provided comparator function should take a, b and return *true* when a < b\nfunction FastPriorityQueue(comparator) {\n    if (!(this instanceof FastPriorityQueue)) return new FastPriorityQueue(comparator);\n    this.array = [];\n    this.size = 0;\n    this.compare = comparator || defaultcomparator;\n}\n\n\n// Add an element the the queue\n// runs in O(log n) time\nFastPriorityQueue.prototype.add = function (myval) {\n    var i = this.size;\n    this.array[this.size] = myval;\n    this.size += 1;\n    var p;\n    var ap;\n    while (i > 0) {\n        p = (i - 1) >> 1;\n        ap = this.array[p];\n        if (!this.compare(myval, ap)) {\n             break;\n        }\n        this.array[i] = ap;\n        i = p;\n    }\n    this.array[i] = myval;\n};\n\n// replace the content of the heap by provided array and \"heapifies it\"\nFastPriorityQueue.prototype.heapify = function (arr) {\n    this.array = arr;\n    this.size = arr.length;\n    var i;\n    for (i = (this.size >> 1); i >= 0; i--) {\n        this._percolateDown(i);\n    }\n};\n\n// for internal use\nFastPriorityQueue.prototype._percolateUp = function (i) {\n    var myval = this.array[i];\n    var p;\n    var ap;\n    while (i > 0) {\n        p = (i - 1) >> 1;\n        ap = this.array[p];\n        if (!this.compare(myval, ap)) {\n            break;\n        }\n        this.array[i] = ap;\n        i = p;\n    }\n    this.array[i] = myval;\n};\n\n\n// for internal use\nFastPriorityQueue.prototype._percolateDown = function (i) {\n    var size = this.size;\n    var hsize = this.size >>> 1;\n    var ai = this.array[i];\n    var l;\n    var r;\n    var bestc;\n    while (i < hsize) {\n        l = (i << 1) + 1;\n        r = l + 1;\n        bestc = this.array[l];\n        if (r < size) {\n            if (this.compare(this.array[r], bestc)) {\n                l = r;\n                bestc = this.array[r];\n            }\n        }\n        if (!this.compare(bestc, ai)) {\n            break;\n        }\n        this.array[i] = bestc;\n        i = l;\n    }\n    this.array[i] = ai;\n};\n\n// Look at the top of the queue (a smallest element)\n// executes in constant time\n//\n// Calling peek on an empty priority queue returns\n// the \"undefined\" value.\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined\n//\nFastPriorityQueue.prototype.peek = function () {\n    if(this.size == 0) return undefined;\n    return this.array[0];\n};\n\n// remove the element on top of the heap (a smallest element)\n// runs in logarithmic time\n//\n// If the priority queue is empty, the function returns the\n// \"undefined\" value.\n// https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined\n//\n// For long-running and large priority queues, or priority queues\n// storing large objects, you may  want to call the trim function\n// at strategic times to recover allocated memory.\nFastPriorityQueue.prototype.poll = function () {\n    if (this.size == 0) \n        return undefined;\n    var ans = this.array[0];\n    if (this.size > 1) {\n        this.array[0] = this.array[--this.size];\n        this._percolateDown(0 | 0);\n    } else {\n        this.size -= 1;\n    }\n    return ans;\n};\n\n\n// This function adds the provided value to the heap, while removing\n//  and returning the peek value (like poll). The size of the priority\n// thus remains unchanged.\nFastPriorityQueue.prototype.replaceTop = function (myval) {\n    if (this.size == 0) \n        return undefined;\n    var ans = this.array[0];\n    this.array[0] = myval;\n    this._percolateDown(0 | 0);\n    return ans;\n};\n\n\n// recover unused memory (for long-running priority queues)\nFastPriorityQueue.prototype.trim = function () {\n    this.array = this.array.slice(0, this.size);\n};\n\n// Check whether the heap is empty\nFastPriorityQueue.prototype.isEmpty = function () {\n    return this.size === 0;\n};\n\n// just for illustration purposes\nvar main = function () {\n    // main code\n    var x = new FastPriorityQueue(function (a, b) {\n        return a < b;\n    });\n    x.add(1);\n    x.add(0);\n    x.add(5);\n    x.add(4);\n    x.add(3);\n    while (!x.isEmpty()) {\n        console.log(x.poll());\n    }\n};\n\nif (require.main === module) {\n    main();\n}\n\nmodule.exports = FastPriorityQueue;\n"]}